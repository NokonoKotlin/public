# 競プロライブラリなど
`ドキュメント最終更新 : 2024/5/7`

ここは以下のコードを置いて置く場所です。
- 普段使いのライブラリの一部
- 定期的に整備するまでもないが、必要な箇所がたまにあるライブラリ 
  - 普段使いライブラリの亜種など
- 登場する場面が少ないが、特別な考察や発想を伴う問題のコード

ライブラリ同士の依存関係はなく、全てのライブラリはこのドキュメントの最後に掲載する `競プロテンプレート` に依存しています (できるだけ依存しないように意識していますが)。


Copyright (c) 2024 NokonoKotlin(okoteiyu) Released under the MIT license(https://opensource.org/licenses/mit-license.php)


## NokonoKotlin のお気持ち
ライセンスを守って使って欲しいよ (ライブラリの冒頭に以下を書くだけ)
- Copyright ©️ (c) 2024 NokonoKotlin(okoteiyu) Released under the MIT license(https://opensource.org/licenses/mit-license.php)




## ライブラリデザイン
ライブラリのデザインについて、方針などをまとめます。
全てのライブラリは `/template/template.hpp` に置いてある `競プロテンプレート` に依存しています。

### 全体の思想&方針

- **「使い勝手/汎用性」,「拡張性/保守性,「シンプルかつ理解しやすい実装/ロジック」** を意識する。
- 依存関係を作らないようにするが、他のライブラリと併用できるような設計にはしておく。  
    - modint を ArraySplayTree に載せるとか  
- **ライブラリ全体を通して、似た機能は同じ方針で設計する。**  
- AtCoder の言語環境に合わせ、新しい良い言語機能はどんどん採用する。
    - 新しい機能にする必要性がない場合や、可読性が下がる場合は採用しない。
        - 例えば `for(auto x : p)` はライブラリでこう書くモチベーションがあまりない。

### クラスに用意するもの
- 基本的に C++ の思想に沿う
    - 目的が競プロである以上、コードのシンプルさを損ねるようなものは書かない方針で行きます。
        - コピーしないクラスのコピーコンストラクタとか
- **メンバとして用意する機能について**
    - クラスの特有/基本的な機能
    - 実用上クラスのメンバにした方が良い機能
    - 実装が複雑で、あらかじめ特殊化しておきたい機能
- **メンバとして用意する例**
    - SuffixTree クラスで SuffixLink を経由して移動するメソッド
    - セグメントツリーの $i$ 番目の要素にアクセスするため、`[]` オペレータを定義する。
    - モノイドの設計が大変なので、Sum,Min,Max に特殊化してクラスに書き込む。
- **メンバとして用意しない例**
    - グリッド上でダイクストラ法を行うことを想定して、頂点番号を整数のペア $(i,j)$ として扱う機能
        - 基本的でも特有でもない上、設計のシンプルさを破壊する。
        - ダイクストラ法にこの機能を用意すると、頂点を扱う他のクラスにも同様の機能を持たる必要が出る。

### 演算子オーバーロード
- modint , Fraction , MyVector などのオブジェクトは、演算子をオーバーロードして直感的に使えるようにする。
- 演算子の設計は C++ の int などの演算子の設計に準拠する (代入の結合など)。
- 左辺値/右辺値 について
    - 基本的に演算子の右辺は const 参照 (`const T&`) で書くが、SplayTree や FPS は勝手に自己の構成を変更するので、場合によっては右辺値参照 (`T&&`) を受け取るようにする。
        - const なメンバ関数 `F` は `F() const& {}` にしておくと右辺値参照でも const 参照でも呼び出せる(当然`F`は const である前提)
    - const に関しての資料はこちら (**TODO:記事を書く**)
- **順序比較について**
    - **`std::partial_ordering <=>(T a , T b)` を使う (`C++20` の機能で、三方演算子というらしい)**
        - `<=>` の実装が返す以下の結果から、`< , <= , > , >=` 演算の結果を作るすごいやつ。
            - `std::partial_ordering::equivalent` : `a` と `b` が等しい
            - `std::partial_ordering::less` : `a` が `b` 未満である
            - `std::partial_ordering::greater` : `a` が `b` より大きい
            - `std::partial_ordering::unordered` : `a` と `b` の順序が未定義
    - 例えば、`0 <=> ∞` が less を返すように実装する。すると、`0 < ∞` の結果が `true` になる。
    - unordered について
        - `a,b` の順序比較ができない時、`unordered` を返し、全ての順序演算が `false` を返す(無限大同士の比較など)。
            - `unordered` な順序があるバブルソートは永遠に終わらない
            - `unordered` な順序がある列をソートすると、`unordered` な順序以外の要素も正しくソートされない
            - できるだけ `unordered` な順序がある要素を比較しない
### **キャストについて**
- **`標準の型/クラス` → `自作クラス` のキャストは暗黙で OK**
    - 基本的に自作クラスの方の機能を参照させたい。
- **`自作クラス` → `標準の型/クラス` のキャストは明示的にする!!!**
    - コンパイラに参照される関数が重複してしまうのを避ける。


#### 実装例
`modint` 同士の比較 ( `modint` の順序は未定義だが、`std::map` に載せるために機能だけ持たせておく。)
```cpp
template<long long mod>
class modint{
    protected:
    long long v;// 内部でもつ値
    public:

    // コンストラクタ兼 int (long long)からの暗黙キャスト
    modint(long long v_){
        v = v_%mod;
        if(v<0)v+=mod;
    }

    // 明示的キャスト
    template<typename T>
    explicit operator T(){return T(this->v);}

    // これだけで modint の <,<=,>,>= の機能を定義できる
    // int → modint は暗黙にキャストされるので、int と modint の比較も定義されている
    // int へのキャストが明示的なので、int と int の比較ではなく、こちらの比較演算が呼ばれる
    friend std::partial_ordering <=>(const modint<mod>& a , const modint<mod>&b){
        return (a.v <=> b.v); // long long の <=> に丸投げする
    }
}
```


## ライブラリの索引と簡単な説明


#### ArraySplayTree
```
列型 SplayTree。SplayTree ライブラリの基本型。
```


#### MyMultiSet  
```
Set 型平衡二分木。機能面では C++ の std::set の上位互換。(互換性は全くない)
```


#### 動的木
- ##### EulerTourTree
    - `根付き木を明示的に管理するのではなく、木のオイラーツアーを SplayTree (列型) で管理する。  `
- ##### Link-Cut Tree
    - `根付き木を明示的に管理するのではなく、木上のパスを SplayTree (列型) で管理する。  `

#### ArithmeticProgression
```
区間に等差数列を 加算/代入 するやつ。スプレー木なのでセグ木より遅いが、挿入/削除をサポートする。
```


#### MyMath::Fraction
```
有理数を表現するクラス。微小量や無限大,曖昧な値を組み込んだらだいぶ手間がかかった。
```


#### MyMultiSet  
```
Set 型平衡二分木。機能面では C++ の std::set の上位互換。(互換性は全くない)
```


#### DynamicSegmentTree
```
動的セグ木。
"動的" というワードが指す内容は流派によって異なるが、ここでは動的に領域を確保することを指す。
遅延評価もついている (区間代入 & 区間アフィン変換)。
```


#### Suffix Tree
```
列に対して接尾辞木を構築する。
Ukkonen's Algorithm を採用(オンライン構築可能)。  
部分文字列系の問題に対する解決策として tier 1 
```


#### 他にもたくさんありますが、長くなるので他は実際に見ていただきたく...
- 暇な時に随時追加していきます。


