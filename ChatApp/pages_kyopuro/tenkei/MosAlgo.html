<!doctype html>
<html lang="ja">
    <link rel="stylesheet" media="screen and (max-width:768px)" href="./../../css/sp_style.css">    
    <link rel="stylesheet" media="screen and (min-width:769px)" href="./../../css/pc_style.css">
    <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    </script>
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        TeX: { equationNumbers: { autoNumber: "AMS" }},
        tex2jax: {
        inlineMath: [ ['$','$'], ["\\(","\\)"] ],
        processEscapes: true
        },
        "HTML-CSS": { matchFontHeight: false },
        displayAlign: "left",
        displayIndent: "2em"
    });
    </script>
    <title>Mo's Algorithm</title>
        

    </head>




    <body>
        
         <!--軽くコメント-->
        <div id="Inner">
            <h_middle style = "text-align: left;"><a href="../../index.html">前のページ</a> </h_middle>
            <section class = "Introduction">
                
                <h_big>   
                    Mo's Algorithm<br></h_big>


            </section>


            <section class = "Explanation">
                <br>
                <br>Mo's Algorithmは、区間に関するクエリの答えるためのアルゴリズムです。
                <br>Mo's Algorithmは、以下の条件を満たす問題に対応することができます。
                <br>&ensp;&ensp;&ensp;&ensp;条件１ : 値の更新がない
                <br>&ensp;&ensp;&ensp;&ensp;条件２ : 区間 [ l , r ) の場合のクエリの解がわかっているときに、区間 [l-1,r) , [l+1,r) , [l,r-1) , [l,r+1) のクエリの答えを高速に計算できる。 
                <br>
                <br>アルゴリズムの大まかな方針は、区間 [ a , b ) のクエリに対する解がわかっているときに、区間 [ a , b ) を左右に拡大/縮小し、計算しながら次のクエリの区間 [ c , d ) に近づけていくというものです。
                <br>
                <br>具体例で言うと、区間[l,r)の総和を求めるクエリの場合、図のように区間を遷移させます
                <br>
                <br><img src = "./../../images/MosAlgo2.png" style = "width : 85%;">
                <br>
                <br>
                <br>しかし、Q 個の区間を愚直に次の区間に遷移させていると、計算量が大きくなってしまいます。
                <br>よって、区間の遷移をより効率的に行う必要があります。
                <br>
                <br>以下の図を見てください。
                <br>
                <br><img src = "./../../images/MosAlgo.png" style = "width : 85%;">
                <br>
                <br>
                <br>図のように並べた区間(クエリ)を、上から遷移しながら処理していきます。
                <br>このとき、クエリの左端(図の赤い点)は一度の遷移で O( √Q ) しか動かないことが図からわかります。
                <br>また、クエリの右端(図の青い点)も、左端が同じ区間では照準になっており、左端が √Q 区画に分かれていることから、最大で N 回右に移動するという操作を √Q 回行うことになります。
                <br>クエリが Q 回飛んでくることから、左端の移動は O( Q√Q ) 、右端の遷移は O( N√Q ) の計算量になります。
                <br>
                <br>なお、区画の番号が奇数番目の時、右端(青い点)を降順ソートにすると、右端が左右に移動することになり、効率が良くなります。
                <br>また、今回の解説では区画を √Q 個に分けていましたが、必ずしも √Q が最適とは限りません。定数倍をかけたり、いろいろ試すと高速化が期待できます。
                <br>
                <br>サンプルコードを貼っておきます。
                <br>
                <br>
                <br>
                <code>
                    <ol style="list-style:decimal-leading-zero outside;in-left:0;padding-left:36px;margin:0;background-color:#EEF;width:90%;line-height: 14px; color:#000;font-size:12px;">
                    <li style="background-color:#EFF;"></li>
                    <li style="background-color:#EEF;"></li>
                    <li style="background-color:#EFF;"></li>
                    <li style="background-color:#EEF;"></li>
                    <li style="background-color:#EFF;"><font style="color:green;font-style:italic;">/*</li>
                    <li style="background-color:#EEF;">&nbsp;&nbsp;&nbsp;&nbsp;Mo's Algorithmの型　</li>
                    <li style="background-color:#EFF;">&nbsp;&nbsp;&nbsp;&nbsp;区間の最大長(数列の長さ)をN、クエリの個数をQとする</li>
                    <li style="background-color:#EEF;"></li>
                    <li style="background-color:#EFF;">&nbsp;&nbsp;&nbsp;&nbsp;クエリの左端の区間を√Qで割り(切り捨て)、左端の値でクエリを√Q個の区間に割り振る(leftを√Qで割った数でソートする)</li>
                    <li style="background-color:#EEF;">&nbsp;&nbsp;&nbsp;&nbsp;そうすることで、√Q個の各区間で、左端を動かしてもO(√Q)の計算量になる</li>
                    <li style="background-color:#EFF;"></li>
                    <li style="background-color:#EEF;">&nbsp;&nbsp;&nbsp;&nbsp;また、同じ区間にあるクエリは右端の値でソートする</li>
                    <li style="background-color:#EFF;">&nbsp;&nbsp;&nbsp;&nbsp;すると、同じ区間内のクエリは、右端を移動しても単調増加であることから計算量はO(N)になる</li>
                    <li style="background-color:#EEF;"></li>
                    <li style="background-color:#EFF;"></li>
                    <li style="background-color:#EEF;">&nbsp;&nbsp;&nbsp;&nbsp;このライブラリは、例題:ABC174-Fに対応しています</li>
                    <li style="background-color:#EFF;"></li>
                    <li style="background-color:#EEF;">&nbsp;&nbsp;&nbsp;&nbsp;テンプレートは元の数列の型 T と、答えを返す時の型 T2を与える</li>
                    <li style="background-color:#EFF;">&nbsp;&nbsp;&nbsp;&nbsp;コンストラクタには元の数列Aと区間の長さN(0-index)を与える。</li>
                    <li style="background-color:#EEF;">&nbsp;&nbsp;&nbsp;&nbsp;(Nが与えられなかったときは、NはAのサイズとする)また、0-indexなので、Nに対して、区間は[0,N)をとる</li>
                    <li style="background-color:#EFF;">&nbsp;&nbsp;&nbsp;&nbsp;クエリをadd_queryで与えたのちに、buildでQやNなどの変数を初期化して計算する(クエリのidは入れた順)</li>
                    <li style="background-color:#EEF;"></li>
                    <li style="background-color:#EFF;">&nbsp;&nbsp;&nbsp;&nbsp;indexを表す値は0-indexとし、区間は半開区間( [ l , r ) := l以上 r未満 )とする </li>
                    <li style="background-color:#EEF;">*/</font></li>
                    <li style="background-color:#EFF;">template&lt;class T , class T2&gt;</li>
                    <li style="background-color:#EEF;">class MosAlgorithm{</li>
                    <li style="background-color:#EFF;">&nbsp;&nbsp;&nbsp;&nbsp;private:</li>
                    <li style="background-color:#EEF;">&nbsp;&nbsp;&nbsp;&nbsp;<font style="color:green;font-style:italic;">//クエリの構造体</font></li>
                    <li style="background-color:#EFF;">&nbsp;&nbsp;&nbsp;&nbsp;struct Query{</li>
                    <li style="background-color:#EEF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int left,right,id;</li>
                    <li style="background-color:#EFF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Query(){}</li>
                    <li style="background-color:#EEF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Query(int left ,int right,int id):left(left),right(right),id(id){}</li>
                    <li style="background-color:#EFF;">&nbsp;&nbsp;&nbsp;&nbsp;};</li>
                    <li style="background-color:#EEF;"></li>
                    <li style="background-color:#EFF;"></li>
                    <li style="background-color:#EEF;"></li>
                    <li style="background-color:#EFF;">&nbsp;&nbsp;&nbsp;&nbsp;</li>
                    <li style="background-color:#EEF;"></li>
                    <li style="background-color:#EFF;">&nbsp;&nbsp;&nbsp;&nbsp;<font style="color:green;font-style:italic;">/*</li>
                    <li style="background-color:#EEF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;クエリの処理の関数や、変数</li>
                    <li style="background-color:#EFF;">&nbsp;&nbsp;&nbsp;&nbsp;*/</font></li>
                    <li style="background-color:#EEF;">&nbsp;&nbsp;&nbsp;&nbsp;public:</li>
                    <li style="background-color:#EFF;"></li>
                    <li style="background-color:#EEF;">&nbsp;&nbsp;&nbsp;&nbsp;long long border;<font style="color:green;font-style:italic;">//クエリのleftを分ける境界線(√Qとか)。ただし、√Qが必ずしも最適ではないので、場合によって定数倍をかけてみたりすると良い</font></li>
                    <li style="background-color:#EFF;">&nbsp;&nbsp;&nbsp;&nbsp;int N,Q;<font style="color:green;font-style:italic;">//数列のサイズ(区間の最大サイズ)と、クエリの個数。ただし、Nは0-indexed</font></li>
                    <li style="background-color:#EEF;">&nbsp;&nbsp;&nbsp;&nbsp;vector&lt;T&gt; A;<font style="color:green;font-style:italic;">//数列</font></li>
                    <li style="background-color:#EFF;">&nbsp;&nbsp;&nbsp;&nbsp;vector&lt;T2&gt; ans;<font style="color:green;font-style:italic;">//答えを格納するvector</font></li>
                    <li style="background-color:#EEF;">&nbsp;&nbsp;&nbsp;&nbsp;int Left,Right;<font style="color:green;font-style:italic;">//今見ている半開区間 : [ Left , Right ) の左右</font></li>
                    <li style="background-color:#EFF;">&nbsp;&nbsp;&nbsp;&nbsp;vector&lt;Query&gt; Queries;</li>
                    <li style="background-color:#EEF;"></li>
                    <li style="background-color:#EFF;">&nbsp;&nbsp;&nbsp;&nbsp;<font style="color:green;font-style:italic;">//例題用</font></li>
                    <li style="background-color:#EEF;">&nbsp;&nbsp;&nbsp;&nbsp;vector&lt;int&gt; cnt;<font style="color:green;font-style:italic;">//cnt[c];=色cが、今見ている区間内に何個あるか</font></li>
                    <li style="background-color:#EFF;">&nbsp;&nbsp;&nbsp;&nbsp;int sum = 0;<font style="color:green;font-style:italic;">//今見ている区間内の色の種類数</font></li>
                    <li style="background-color:#EEF;"></li>
                    <li style="background-color:#EFF;"></li>
                    <li style="background-color:#EEF;">&nbsp;&nbsp;&nbsp;&nbsp;<font style="color:green;font-style:italic;">//クエリの区間を拡大した時の更新関数(現在見ている区間に、iを加える(iは区間の端と隣接している必要がある))</font></li>
                    <li style="background-color:#EFF;">&nbsp;&nbsp;&nbsp;&nbsp;void add(int i){</li>
                    <li style="background-color:#EEF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(cnt[A[i]] == 0)sum++;<font style="color:green;font-style:italic;">//種類数の更新</font></li>
                    <li style="background-color:#EFF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cnt[A[i]]++;</li>
                    <li style="background-color:#EEF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</li>
                    <li style="background-color:#EFF;">&nbsp;&nbsp;&nbsp;&nbsp;}</li>
                    <li style="background-color:#EEF;"></li>
                    <li style="background-color:#EFF;">&nbsp;&nbsp;&nbsp;&nbsp;<font style="color:green;font-style:italic;">//クエリの区間を縮小したときの更新関数(現在見ている区間から、iを取り除く(iは区間の端である必要がある))</font></li>
                    <li style="background-color:#EEF;">&nbsp;&nbsp;&nbsp;&nbsp;void remove(int i){</li>
                    <li style="background-color:#EFF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;cnt[A[i]]--;</li>
                    <li style="background-color:#EEF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(cnt[A[i]] == 0 )sum--;<font style="color:green;font-style:italic;">//種類数の更新</font></li>
                    <li style="background-color:#EFF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</li>
                    <li style="background-color:#EEF;">&nbsp;&nbsp;&nbsp;&nbsp;}  </li>
                    <li style="background-color:#EFF;"></li>
                    <li style="background-color:#EEF;">&nbsp;&nbsp;&nbsp;&nbsp;<font style="color:green;font-style:italic;">//i番目のクエリの答えを書き込む</font></li>
                    <li style="background-color:#EFF;">&nbsp;&nbsp;&nbsp;&nbsp;void write(int i){</li>
                    <li style="background-color:#EEF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;ans[i] = sum;</li>
                    <li style="background-color:#EFF;">&nbsp;&nbsp;&nbsp;&nbsp;}</li>
                    <li style="background-color:#EEF;"></li>
                    <li style="background-color:#EFF;"></li>
                    <li style="background-color:#EEF;"></li>
                    <li style="background-color:#EFF;">&nbsp;&nbsp;&nbsp;&nbsp;public:</li>
                    <li style="background-color:#EEF;"></li>
                    <li style="background-color:#EFF;">&nbsp;&nbsp;&nbsp;&nbsp;MosAlgorithm(){}</li>
                    <li style="background-color:#EEF;">&nbsp;&nbsp;&nbsp;&nbsp;MosAlgorithm(vector&lt;T&gt; A_ , int N_ = -1){</li>
                    <li style="background-color:#EFF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A = A_;</li>
                    <li style="background-color:#EEF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(N_==-1)N = A.size();</li>
                    <li style="background-color:#EFF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else N = N_;</li>
                    <li style="background-color:#EEF;">&nbsp;&nbsp;&nbsp;&nbsp;}</li>
                    <li style="background-color:#EFF;"></li>
                    <li style="background-color:#EEF;">&nbsp;&nbsp;&nbsp;&nbsp;<font style="color:green;font-style:italic;">/*</li>
                    <li style="background-color:#EFF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;クエリを追加する(l,r,は半開区間 : [ l , r ) )</li>
                    <li style="background-color:#EEF;">&nbsp;&nbsp;&nbsp;&nbsp;*/</font></li>
                    <li style="background-color:#EFF;">&nbsp;&nbsp;&nbsp;&nbsp;void add_query(int l , int r){</li>
                    <li style="background-color:#EEF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Queries.emplace_back(l,r,(int)Queries.size());</li>
                    <li style="background-color:#EFF;">&nbsp;&nbsp;&nbsp;&nbsp;}</li>
                    <li style="background-color:#EEF;"></li>
                    <li style="background-color:#EFF;">&nbsp;&nbsp;&nbsp;&nbsp;<font style="color:green;font-style:italic;">/*</li>
                    <li style="background-color:#EEF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;コンストラクタやadd_queryで与えられた問題を解いて、ans配列に書き込む</li>
                    <li style="background-color:#EFF;">&nbsp;&nbsp;&nbsp;&nbsp;*/</font></li>
                    <li style="background-color:#EEF;">&nbsp;&nbsp;&nbsp;&nbsp;void build(){</li>
                    <li style="background-color:#EFF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font style="color:green;font-style:italic;">//変数の初期化</font></li>
                    <li style="background-color:#EEF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Q = Queries.size();<font style="color:green;font-style:italic;">//クエリの個数の初期化</font></li>
                    <li style="background-color:#EFF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vector&lt;T2&gt;(Q).swap(ans);<font style="color:green;font-style:italic;">//ansの初期化</font></li>
                    <li style="background-color:#EEF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;vector&lt;int&gt;(N+1).swap(cnt);</li>
                    <li style="background-color:#EFF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sum = 0;</li>
                    <li style="background-color:#EEF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;border = (long long)sqrt(Q) + 1;</li>
                    <li style="background-color:#EFF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                    <li style="background-color:#EEF;"></li>
                    <li style="background-color:#EFF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font style="color:green;font-style:italic;">//クエリをソート</font></li>
                    <li style="background-color:#EEF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;sort(Queries.begin() , Queries.end() , [&amp;](Query a , Query b){</li>
                    <li style="background-color:#EFF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int aL = a.left/border;</li>
                    <li style="background-color:#EEF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int bL = b.left/border;</li>
                    <li style="background-color:#EFF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if( aL &lt; bL )return true;</li>
                    <li style="background-color:#EEF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else if( aL == bL ){</li>
                    <li style="background-color:#EFF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;if(aL%2==0)return a.right&lt;b.right;<font style="color:green;font-style:italic;">//右は交互に左右に動かす方がメモリアクセスの点で高速になる</font></li>
                    <li style="background-color:#EEF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;else return !(a.right&lt;b.right);</li>
                    <li style="background-color:#EFF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}else return false;</li>
                    <li style="background-color:#EEF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;});</li>
                    <li style="background-color:#EFF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                    <li style="background-color:#EEF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Left = 0;</li>
                    <li style="background-color:#EFF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Right = 0;</li>
                    <li style="background-color:#EEF;"></li>
                    <li style="background-color:#EFF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for(Query q : Queries){</li>
                    <li style="background-color:#EEF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font style="color:green;font-style:italic;">//今見ている区間を、見ているクエリの区間に拡大(縮小)する</font></li>
                    <li style="background-color:#EFF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int next_l = q.left;</li>
                    <li style="background-color:#EEF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;int next_r = q.right;</li>
                    <li style="background-color:#EFF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                    <li style="background-color:#EEF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font style="color:green;font-style:italic;">//広げてから縮小する！！</font></li>
                    <li style="background-color:#EFF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(next_l &lt; Left)add(Left-1),Left--;</li>
                    <li style="background-color:#EEF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(Right &lt; next_r)add(Right),Right++;</li>
                    <li style="background-color:#EFF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(Left &lt; next_l)remove(Left),Left++;</li>
                    <li style="background-color:#EEF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;while(next_r &lt; Right)remove(Right-1),Right--;</li>
                    <li style="background-color:#EFF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</li>
                    <li style="background-color:#EEF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;write(q.id);</li>
                    <li style="background-color:#EFF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;}</li>
                    <li style="background-color:#EEF;">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return;</li>
                    <li style="background-color:#EFF;">&nbsp;&nbsp;&nbsp;&nbsp;}</li>
                    <li style="background-color:#EEF;"></li>
                    <li style="background-color:#EFF;">};</li>
                    <li style="background-color:#EEF;"></li>
                    <li style="background-color:#EFF;"></li>
                    <li style="background-color:#EEF;"></li>
                    </ol>
                </code>






                
            </section>



        </div>



    </body>


</html>
