# ライブラリデザイン
`ドキュメント最終更新 : 2024/5/15`


### 全体の思想&方針

- **「使い勝手/汎用性」,「拡張性/保守性,「シンプルかつ理解しやすい実装/ロジック」** を意識する。
- 依存関係を作らないようにするが、他のライブラリと併用できるような設計にはしておく。  
    - modint を ArraySplayTree に載せるとか  
- **ライブラリ全体を通して、似た機能は同じ方針で設計する。**  
- AtCoder の言語環境に合わせ、新しい良い言語機能はどんどん採用する。
    - 新しい機能にする必要性がない場合や、可読性が下がる場合は採用しない。
        - 例えば `for(auto x : p)` はライブラリでこう書くモチベーションがあまりない。

### クラスに用意するもの
- 基本的に C++ の思想に沿う
    - 目的が競プロである以上、コードのシンプルさを損ねるようなものは書かない方針で行きます。
        - コピーしないクラスのコピーコンストラクタとか
- **メンバとして用意する機能について**
    - クラスの特有/基本的な機能
    - 実用上クラスのメンバにした方が良い機能
    - 実装が複雑で、あらかじめ特殊化しておきたい機能
- **メンバとして用意する例**
    - SuffixTree クラスで SuffixLink を経由して移動するメソッド
    - セグメントツリーの $i$ 番目の要素にアクセスするため、`[]` オペレータを定義する。
    - モノイドの設計が大変なので、Sum,Min,Max に特殊化してクラスに書き込む。
- **メンバとして用意しない例**
    - グリッド上でダイクストラ法を行うことを想定して、頂点番号を整数のペア $(i,j)$ として扱う機能
        - 基本的でも特有でもない上、設計のシンプルさを破壊する。
        - ダイクストラ法にこの機能を用意すると、頂点を扱う他のクラスにも同様の機能を持たる必要が出る。

### 演算子オーバーロード
- modint , Fraction , MyVector などのオブジェクトは、演算子をオーバーロードして直感的に使えるようにする。
- 演算子の設計は C++ の int などの演算子の設計に準拠する (代入の結合など)。
- 左辺値/右辺値 について
    - 基本的に演算子の両辺は const 参照 (`const T&`) で書くが、SplayTree や FPS は勝手に自己の構成を変更するので、場合によっては右辺値参照 (`T&&`) を受け取るようにする。
        - const なメンバ関数 `F` は `F() const& {}` にしておくと右辺値参照でも const 参照でも呼び出せる(当然`F`は const である前提)
    - const に関しての資料はこちら (**TODO:記事を書く**)
- **順序比較について**
    - **`std::partial_ordering <=>(T a , T b)` を使う (`C++20` の機能で、三方演算子というらしい)**
        - `<=>` の実装が返す以下の結果から、`< , <= , > , >=` 演算の結果を作るすごいやつ。
            - `std::partial_ordering::equivalent` : `a` と `b` が等しい
            - `std::partial_ordering::less` : `a` が `b` 未満である
            - `std::partial_ordering::greater` : `a` が `b` より大きい
            - `std::partial_ordering::unordered` : `a` と `b` の順序が未定義
    - 例えば、`0 <=> ∞` が less を返すように実装する。すると、`0 < ∞` の結果が `true` になる。
    - unordered について
        - `a,b` の順序比較ができない時、`unordered` を返し、全ての順序演算が `false` を返す(無限大同士の比較など)。
            - `unordered` な順序があるバブルソートは永遠に終わらない
            - `unordered` な順序がある列をソートすると、`unordered` な順序以外の要素も正しくソートされない
            - できるだけ `unordered` な順序がある要素を比較しない
### **キャストについて**
- **`標準の型/クラス` → `自作クラス` のキャストは暗黙で OK**
    - 基本的に自作クラスの方の機能を参照させたい。
- **`自作クラス` → `標準の型/クラス` のキャストは明示的にする!!!**
    - コンパイラに参照される関数が重複してしまうのを避ける。


#### 実装例
`modint` 同士の比較 ( `modint` の順序は未定義だが、`std::map` に載せるために機能だけ持たせておく。)
```cpp
template<long long mod>
class modint{
    protected:
    long long v;// 内部でもつ値
    public:

    // コンストラクタ兼 int (long long)からの暗黙キャスト
    modint(long long v_){
        v = v_%mod;
        if(v<0)v+=mod;
    }

    // 明示的キャスト
    template<typename T>
    explicit operator T(){return T(this->v);}

    // これだけで modint の <,<=,>,>= の機能を定義できる
    // int → modint は暗黙にキャストされるので、int と modint の比較も定義されている
    // int と int の比較はここでは呼ばれない。(おそらく C++ のキャストの順序の関係??? 要勉強 )
    friend std::partial_ordering <=>(const modint<mod>& a , const modint<mod>&b){
        return (a.v <=> b.v); // long long の <=> に丸投げする
    }
}
```